# Tutor-IA

## √çndice

1. [Introducci√≥n](#introducci√≥n)
2. [Arquitectura y Tecnolog√≠as](#arquitectura-y-tecnolog√≠as-utilizadas)
3. [Instalaci√≥n y Ejecuci√≥n](#-instalaci√≥n-y-ejecuci√≥n)
4. [Funcionamiento del sistema RAG](#funcionamiento-del-sistema-rag)
5. [Casos de uso recomendados](#casos-de-uso-recomendados)
6. [Checklist de contribuci√≥n o desarrollo futuro](#checklist-de-contribuci√≥n-o-desarrollo-futuro)
7. [API](#api-de-gesti√≥n-de-apuntes-y-tutor√≠a)


# Introducci√≥n

**Tutor-IA** es una plataforma educativa potenciada por inteligencia artificial dise√±ada para facilitar el estudio a trav√©s del procesamiento y explicaci√≥n personalizada de apuntes. Su objetivo principal es ayudar a estudiantes a comprender mejor sus materiales acad√©micos, respondiendo a preguntas, generando res√∫menes y ofreciendo explicaciones adaptadas al nivel y contexto del alumno.

Esta herramienta combina modelos de lenguaje avanzados con t√©cnicas de recuperaci√≥n de informaci√≥n para garantizar respuestas precisas basadas en los apuntes propios del estudiante, fomentando un aprendizaje eficiente y personalizado.

# Arquitectura y Tecnolog√≠as Utilizadas

Tutor-IA est√° construido sobre una arquitectura moderna que combina servicios backend robustos con una interfaz de usuario intuitiva. A continuaci√≥n, se describen las principales tecnolog√≠as y componentes que conforman el proyecto:

- **FastAPI:** Framework para la creaci√≥n de APIs RESTful r√°pidas y eficientes en Python. Se utiliza para gestionar las peticiones del frontend y ejecutar la l√≥gica de negocio, incluyendo la integraci√≥n con modelos de lenguaje y procesamiento de documentos.

- **Streamlit:** Biblioteca para construir interfaces web interactivas y f√°ciles de usar, orientada a aplicaciones de datos y machine learning. En Tutor-IA, Streamlit ofrece la UI donde los usuarios pueden interactuar con el tutor y gestionar sus apuntes.

- **Modelos de lenguaje (LLM):** Se emplean modelos como GPT-3.5 o Groq para generar respuestas y explicaciones basadas en el contexto proporcionado por los apuntes del usuario, utilizando t√©cnicas de Recuperaci√≥n Aumentada por Generaci√≥n (RAG).

- **RAG (Retrieval-Augmented Generation):** T√©cnica que combina b√∫squeda de informaci√≥n en documentos relevantes con generaci√≥n de texto para proporcionar respuestas m√°s precisas y contextualizadas. Tutor-IA utiliza RAG para buscar fragmentos relevantes de los apuntes y enriquecer las respuestas del modelo.

- **FAISS (Facebook AI Similarity Search):** Motor de b√∫squeda eficiente para grandes colecciones de vectores que permite realizar b√∫squedas r√°pidas de fragmentos de texto similares. En Tutor-IA, FAISS almacena y consulta las representaciones vectoriales de los chunks de apuntes para facilitar la recuperaci√≥n de informaci√≥n contextual.

- **Almacenamiento y Procesamiento de Apuntes:** Los documentos subidos por el usuario se procesan y segmentan en chunks para su posterior indexaci√≥n y b√∫squeda contextual mediante FAISS.

Esta combinaci√≥n tecnol√≥gica asegura un sistema escalable, eficiente y con una experiencia de usuario centrada en la personalizaci√≥n y calidad educativa.


# API de Gesti√≥n de Apuntes y Tutor√≠a

Esta API ofrece un conjunto de endpoints dise√±ados para gestionar apuntes acad√©micos, responder preguntas basadas en contenido vectorizado (RAG), evaluar desarrollos, generar explicaciones adaptadas y enriquecer apuntes. Est√° construida sobre FastAPI y usa tecnolog√≠as como FAISS para b√∫squeda vectorial y el modelo Groq para generaci√≥n de lenguaje natural.

## ‚öôÔ∏è Instalaci√≥n y Ejecuci√≥n

### üìã Requisitos del Sistema

- Python 3.10 o superior
- Git instalado
- Recomendado: entorno virtual (venv, poetry o conda)
- Conexi√≥n a internet para instalaci√≥n de dependencias y uso de Groq API y OpenAi API

---

### üß™ Instrucciones Paso a Paso

#### 1. üîÑ Clonar el repositorio

```bash
git clone https://github.com/tuusuario/tutor-ia.git
cd tutor-ia
```

#### 2. üß∞ Crear el entorno virtual
```bash
python3 -m venv .venv
source .venv/bin/activate   # En Linux/macOS
.venv\Scripts\activate      # En Windows
```

#### 3. üì¶ Instalar dependencias
```bash
pip install -r requirements.txt
```

#### 4. üöÄ Lanzar la API
```bash
uvicorn src.api.main:app --reload
```
La API estar√° disponible en http://localhost:8000
Puedes acceder a la documentaci√≥n interactiva Swagger en http://localhost:8000/docs

Recuerda definir tu archivo .env con las claves necesarias, como GROQ_API_KEY, antes de lanzar la API.

#### 5. üñ•Ô∏è Lanzar la interfaz en Streamlit

```bash
streamlit run interfaz/main.py
```

# Endpoints Principales

## 1. /responder_pregunta (GET) (Deprecado)

Descripci√≥n:
Responde a una pregunta espec√≠fica basada en la materia y tema indicados, usando un enfoque Retrieval-Augmented Generation (RAG) para aprovechar el contexto de los apuntes.

Par√°metros:
	‚Ä¢	materia (string, requerido): Nombre de la materia.
	‚Ä¢	tema (string, requerido): Nombre del tema dentro de la materia.
	‚Ä¢	pregunta (string, requerido): La pregunta que desea responder el usuario.

Respuesta:

```json
{ "respuesta": "Texto con la respuesta generada basada en los apuntes." }
```

## 2. /explicar_ como_nino (GET)

Descripci√≥n:
Genera una explicaci√≥n de un tema espec√≠fico, adaptada para que un ni√±o de 12 a√±os pueda entenderla.

Par√°metros:
	‚Ä¢	materia (string, requerido): Nombre de la materia.
	‚Ä¢	tema (string, requerido): Nombre del tema dentro de la materia.

Respuesta:

```json
{
	"explicacion": "Texto explicativo simplificado para ni√±os."
}
```

## 3. /procesar_apunte (POST)

Descripci√≥n:
Procesa un nuevo archivo de apunte subido por el usuario, analiza su contenido, lo divide en chunks y actualiza el vectorstore correspondiente.

Par√°metros:
	‚Ä¢	materia (form data, requerido): Nombre de la materia.
	‚Ä¢	tema (form data, requerido): Nombre del tema.
	‚Ä¢	archivo (file, requerido): Archivo de apunte en formato compatible.

```json
{
  "mensaje": "Mensaje indicando el resultado del procesamiento."
}
```

## 4. /evaluar_desarrollo (POST)

Descripci√≥n:
Eval√∫a un desarrollo escrito por el alumno compar√°ndolo con los apuntes disponibles para la materia y tema indicados.

Par√°metros (JSON body):
	‚Ä¢	materia (string): Nombre de la materia.
	‚Ä¢	tema (string): Nombre del tema.
	‚Ä¢	titulo_tema (string): T√≠tulo del desarrollo.
	‚Ä¢	desarrollo (string): Texto del desarrollo a evaluar.

Respuesta:

```json
{
  "evaluacion": "Resultado cuantitativo o cualitativo de la evaluaci√≥n."
}
```
## 5. /materias (GET)

Descripci√≥n:
Devuelve un listado de todas las materias disponibles (directorio de vectorstores).

Respuesta

```json
[
  "historia",
  "matematicas",
  "biologia"
]
```

## 6. /temas (GET)

Descripci√≥n:
Devuelve un listado de los temas disponibles para una materia concreta.

Par√°metros:
	‚Ä¢	materia (string, requerido): Nombre de la materia.

Respuesta:

```json
[
  "Segunda guerra mundial",
  "Edad media",
  "Renacimiento"
]
```

## 7. /debug/vectorstores (GET)

Descripci√≥n:
Endpoint de depuraci√≥n para listar todos los vectorstores existentes en el sistema.

Respuesta:

```json
[
  "historia__segunda_guerra_mundial",
  "matematicas__algebra",
  "biologia__celulas"
]
```

## 8. /enriquecer_apuntes (POST)

Descripci√≥n:
Permite enriquecer apuntes existentes con informaci√≥n adicional generada autom√°ticamente, actualizando la base de datos de chunks y temas.

Par√°metros:
	‚Ä¢	materia (string, requerido): Nombre de la materia.
	‚Ä¢	tema (string, requerido): Nombre del tema.

```json	
{
  "mensaje": {
    "chunks_creados": 10,
    "subtemas_agregados": ["subtema1", "subtema2"],
    "detalle": []
  },
  "ya_analizado": false
}
```

## 9. /generar_ clase_magistral (POST)

Descripci√≥n:
Genera una clase magistral completa para una materia y tema dados, combinando subtemas y almacenando el resultado en los apuntes.

Par√°metros:
	‚Ä¢	materia (string, requerido): Nombre de la materia.
	‚Ä¢	tema (string, requerido): Nombre del tema.

Respuesta:

```json
{
  "mensaje": "Clase magistral generada correctamente."
}
```

## 10. /chat_ explica_simple (POST)

Descripci√≥n:
API para el chatbot que responde preguntas bas√°ndose en el contexto de apuntes, con manejo avanzado de preguntas fuera de contexto y fallback para respuestas gen√©ricas.

Par√°metros (JSON body):
	‚Ä¢	materia (string): Materia de referencia.
	‚Ä¢	tema (string): Tema de referencia.
	‚Ä¢	historial (lista de mensajes): Historial de la conversaci√≥n.

Respuesta:

```json
{
  "respuesta": "Respuesta del tutor acad√©mico.",
  "historial": [
    {"role": "usuario", "content": "¬øQui√©n fue Hitler?"},
    {"role": "tutor", "content": "Respuesta detallada basada en apuntes e IA."}
  ]
}
```

# üèóÔ∏è Arquitectura del Proyecto

La arquitectura de `Tutor-IA` est√° organizada en una estructura modular y escalable, orientada a facilitar el desarrollo de funcionalidades educativas basadas en IA. A continuaci√≥n se detalla la estructura principal del proyecto y la funci√≥n de cada carpeta o archivo relevante:

### üìÅ Estructura principal del proyecto

```plaintext
tutor-ia/
‚îú‚îÄ‚îÄ .devcontainer/              # Configuraci√≥n para contenedores de desarrollo (opcional)
‚îú‚îÄ‚îÄ .env                        # Variables de entorno locales
‚îú‚îÄ‚îÄ .gitattributes              # Reglas de Git para atributos de archivos
‚îú‚îÄ‚îÄ .gitignore                  # Archivos y carpetas ignoradas por Git
‚îú‚îÄ‚îÄ audios/                     # Carpeta para audios generados (opcional)
‚îú‚îÄ‚îÄ data/                       # Carpeta para datos adicionales (p. ej., docs.json)
‚îú‚îÄ‚îÄ logs_chat.txt               # Registro de interacciones del chat
‚îú‚îÄ‚îÄ README.md                   # Documentaci√≥n principal del proyecto
‚îú‚îÄ‚îÄ requirements.txt            # Dependencias del proyecto
‚îú‚îÄ‚îÄ runtime.txt                 # Requisito de entorno para despliegues (ej. Render)
‚îú‚îÄ‚îÄ streamlit_app.py            # Frontend visual del proyecto en Streamlit
‚îú‚îÄ‚îÄ tutor_ia_logo.png           # Logo del proyecto
‚îú‚îÄ‚îÄ uploads/                    # Apuntes PDF subidos por el usuario
‚îú‚îÄ‚îÄ src/                        # C√≥digo fuente principal
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes/             # Endpoints de FastAPI, incluyendo CLI y Chat
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ cli_routes.py   # Punto principal de la API
‚îÇ   ‚îú‚îÄ‚îÄ apuntes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rag/                # M√≥dulos de vectorizaci√≥n y b√∫squeda
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vectorstores/   # FAISS Vectorstores generados por materia/tema
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ scripts/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ agents/         # Agentes generativos (clase magistral, enriquecimiento, etc.)
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ agent_tools.py  # Herramientas de postprocesado
‚îÇ   ‚îú‚îÄ‚îÄ services/               # L√≥gica de negocio para responder, evaluar, enriquecer, etc.
‚îÇ   ‚îî‚îÄ‚îÄ config.py               # Variables de entorno y claves API
‚îî‚îÄ‚îÄ main.py                     # Entry point para lanzar FastAPI
```

### üß© M√≥dulos clave

- **`api/routes/cli_routes.py`**  
  Contiene todos los endpoints expuestos por FastAPI: subida de apuntes, generaci√≥n de clases magistrales, chat educativo, enriquecimiento, etc.

- **`apuntes/rag/`**  
  Aqu√≠ se almacenan los vectorstores de FAISS que permiten b√∫squedas sem√°nticas r√°pidas sobre los apuntes vectorizados.

- **`apuntes/scripts/agents/`**  
  Agentes que generan contenido autom√°ticamente: clases magistrales, subtemas avanzados, validaci√≥n de calidad, etc.

- **`services/`**  
  Funciones core que procesan peticiones, ejecutan l√≥gica y devuelven respuestas. Es la capa intermedia entre los endpoints y los modelos o herramientas externas.

- **`uploads/`**  
  Carpeta donde se almacenan temporalmente los archivos PDF subidos antes de ser procesados.

- **`config.py`**  
  Define variables como claves de API, rutas por defecto y configuraciones reutilizables.


## üîÑ Flujo de Trabajo: Subida de Apuntes ‚Üí Vectorizaci√≥n ‚Üí Consulta ‚Üí Enriquecimiento

El flujo principal del proyecto **Tutor-IA** sigue una secuencia l√≥gica que permite aprovechar al m√°ximo los apuntes del estudiante mediante t√©cnicas de procesamiento, b√∫squeda sem√°ntica y generaci√≥n asistida por IA:

1. **üì§ Subida del Apunte**  
   El usuario sube un archivo PDF a trav√©s del endpoint `/procesar_apunte`, indicando la `materia` y el `tema` correspondiente.

2. **üßπ Limpieza y Troceado**  
   El contenido del PDF se convierte en texto, se limpia (eliminando cabeceras, repeticiones, frases limitantes...) y se divide en fragmentos (chunks) coherentes desde el punto de vista sem√°ntico.

3. **üì¶ Vectorizaci√≥n e Indexaci√≥n (FAISS)**  
   Los chunks son transformados en vectores mediante un modelo de embeddings. Estos vectores se almacenan en √≠ndices FAISS separados por `materia` y `tema`, permitiendo b√∫squedas eficientes por similitud sem√°ntica.

4. **üîç Consulta del Usuario (RAG)**  
   Cuando el usuario realiza una pregunta, el sistema localiza los chunks m√°s relevantes mediante b√∫squeda vectorial y construye un prompt contextualizado que se env√≠a a un modelo LLM (Groq) para generar una respuesta fundamentada en los apuntes del alumno.

5. **üß† Enriquecimiento Semiautom√°tico**  
   A trav√©s del endpoint `/enriquecer_apuntes`, el sistema analiza los apuntes existentes, detecta lagunas de contenido, y sugiere subtemas adicionales. Luego genera desarrollos completos para cada subtema y los incorpora al vectorstore, ampliando as√≠ la base de conocimiento sin intervenci√≥n manual.

Este flujo garantiza que el sistema evolucione con el tiempo, se mantenga centrado en los contenidos del estudiante, y mejore progresivamente su capacidad de respuesta mediante enriquecimiento continuo.

## üß† Funcionamiento del sistema RAG

### üîç ¬øQu√© es RAG (Retrieval-Augmented Generation)?

**RAG** es una t√©cnica que combina dos enfoques en modelos de lenguaje:

- **Retrieval** (recuperaci√≥n): busca informaci√≥n relevante en una base de datos o documentos antes de responder.
- **Augmented Generation** (generaci√≥n aumentada): el modelo genera la respuesta bas√°ndose tanto en el contexto recuperado como en su conocimiento general.

Esto permite generar respuestas **m√°s precisas y personalizadas**, incluso en dominios espec√≠ficos como apuntes acad√©micos.

---

### üßæ ¬øC√≥mo se usan FAISS y los apuntes vectorizados?

1. üì• Cuando un estudiante sube un apunte en PDF, se analiza y se divide en fragmentos o *chunks* de texto.
2. üß† Cada fragmento se convierte en un vector num√©rico utilizando modelos de embeddings de Hugging Face.
3. üíæ Estos vectores se almacenan en un √≠ndice **FAISS**, organizado por materia y tema (`src/apuntes/rag/vectorstores`).
4. üîé Cuando se hace una pregunta, se transforma en vector y se compara con los fragmentos existentes en FAISS.
5. üìö Los fragmentos m√°s similares (contexto relevante) se pasan como input al modelo generativo para producir una respuesta fundamentada.

---

### ü§î ¬øCu√°ndo se considera una pregunta relevante?

El sistema utiliza la funci√≥n `es_pregunta_relevante()` del m√≥dulo `rag_local.py`, que:

1. Convierte la pregunta en vector.
2. La compara con los vectores de los apuntes del tema correspondiente.
3. Si alguno supera un umbral de similitud determinado, se considera **relevante**.

---

### ‚öñÔ∏è ¬øY si no es relevante?

- Si la pregunta no es considerada relevante, se comprueba si es una **pregunta gen√©rica** (ej. "hazme un resumen").
- En ese caso, se fuerza una b√∫squeda contextual amplia usando todo el tema.
- Si no encaja en ninguna categor√≠a, el sistema devuelve un mensaje indicando que no puede responder fuera de contexto.

---

> üß† Este enfoque permite un equilibrio entre precisi√≥n y flexibilidad, dando prioridad a la informaci√≥n contenida en los apuntes y evitando respuestas alucinadas.

## ‚úÖ Casos de uso recomendados

Esta plataforma est√° dise√±ada para estudiantes y profesionales que deseen **aprovechar la inteligencia artificial para mejorar su aprendizaje**. A continuaci√≥n, se describen los principales casos de uso:

---

### üì§ Subir apuntes y enriquecerlos autom√°ticamente

- Los usuarios pueden subir apuntes en formato PDF clasificados por **materia** y **tema**.
- El sistema analiza el contenido, lo vectoriza y lo almacena de forma eficiente.
- Luego, se puede ejecutar un proceso de **enriquecimiento autom√°tico** que detecta lagunas de contenido y a√±ade subtemas desarrollados por la IA, mejorando as√≠ la calidad del material de estudio.

---

### ‚ùì Formular preguntas sobre temas concretos

- El usuario puede hacer preguntas directamente sobre los temas que ha subido.
- El sistema utiliza RAG (Retrieval-Augmented Generation) para buscar informaci√≥n relevante en los apuntes y generar una respuesta coherente, confiable y adaptada.
- Tambi√©n se pueden hacer preguntas gen√©ricas como ‚Äúhazme un resumen‚Äù o ‚Äúexplica este tema‚Äù.

---

### üßë‚Äçüè´ Simular conversaciones educativas con IA

- Mediante el chat integrado, es posible mantener una conversaci√≥n fluida con un **tutor acad√©mico virtual**.
- Se puede pedir explicaciones con distintos niveles de complejidad, incluyendo el modo **‚Äúexpl√≠calo como si tuviera 12 a√±os‚Äù**.
- Ideal para repasar, resolver dudas o reforzar el aprendizaje de forma interactiva.

---

> üìö La plataforma no solo responde, sino que tambi√©n **eval√∫a desarrollos escritos**, genera clases magistrales completas y ofrece un sistema adaptable al progreso del estudiante.

## üõ†Ô∏è Checklist de contribuci√≥n o desarrollo futuro

Este proyecto est√° en constante evoluci√≥n. A continuaci√≥n se presentan ideas, tareas pendientes y mejoras sugeridas para colaboradores o para el propio roadmap del proyecto.

---

> ‚ú® Si quieres contribuir, abre un Pull Request con una descripci√≥n clara de la mejora y aseg√∫rate de mantener la coherencia con la arquitectura general del proyecto.



---

## üõ°Ô∏è Archivo `.env` requerido

Crea un archivo `.env` en la ra√≠z del proyecto con al menos la siguiente clave:

```env
GROQ_API_KEY=tu_clave_groq_aqui
```


---

## üë• Autores

Este proyecto ha sido desarrollado por Eugenio Barqu√≠n en el marco de la III Edicion del  Bootcamp Inteligencia Artificial Full Stack de KeepCoding 

## üìÑ Licencia

Distribuido bajo la licencia MIT. Consulta el archivo LICENSE para m√°s informaci√≥n.
